// Basic Phaser Scene
class MainScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MainScene' });
        this.currentShapes = [];
        this.shapeData = []; // To store vertices of the current shape {x, y, isVertex: true/false}
        this.selectedPoints = []; // Stores {x,y} of clicked points
        this.selectionMarkers = []; // Stores graphics objects for point markers & lines
        this.measurementText = null; // Stores the text object for displaying measurements
    }

    preload() {
        // Will be used to load assets
        console.log('MainScene preload');
    }

    create() {
        console.log('MainScene create');

        const newShapeButton = this.add.text(100, 30, 'New Shape', { // Adjusted Y to 30
            font: '24px Arial',
            fill: '#0000ff',
            backgroundColor: '#cccccc',
            padding: { x: 10, y: 5 }
        });
        newShapeButton.setInteractive();
        newShapeButton.on('pointerdown', () => {
            this.clearMeasurements(); // Clear measurements when new shape is made
            this.createRandomShape();
        });

        this.input.on('pointerdown', this.handlePointSelection, this);

        this.createRandomShape(); // Initial shape
    }

    clearMeasurements() {
        this.selectedPoints = [];
        if (this.selectionMarkers) {
            this.selectionMarkers.forEach(marker => marker.destroy());
        }
        this.selectionMarkers = [];
        if (this.measurementText) {
            this.measurementText.destroy();
            this.measurementText = null;
        }
    }

    clearShapes() {
        if (this.currentShapes) {
            this.currentShapes.forEach(shape => shape.destroy());
        }
        this.currentShapes = [];
        this.shapeData = []; // Also clear shape data
    }

    createRandomShape() {
        this.clearShapes(); // This now also clears shapeData
        // this.clearMeasurements(); // Called by button, or if shapes can be generated by other means.
                                 // For now, new shape button is the only way, which calls it.

        const graphics = this.add.graphics();
        this.currentShapes.push(graphics); // Store the graphics object

        const shapeType = Phaser.Math.Between(0, 2); // 0: rectangle, 1: triangle, 2: circle
        const color = Phaser.Display.Color.RandomRGB().color;
        graphics.fillStyle(color, 0.7);
        graphics.lineStyle(2, 0x000000, 1);

        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        const buttonAndMarginHeight = 80; // Approx height occupied by button and some margin

        if (shapeType === 0) { // Rectangle
            const rw = Phaser.Math.Between(50, 100);
            const rh = Phaser.Math.Between(50, 100);
            const rx = Phaser.Math.Between(50, gameWidth - rw - 50);
            const ry = Phaser.Math.Between(buttonAndMarginHeight, gameHeight - rh - 50);
            graphics.fillRect(rx, ry, rw, rh);
            graphics.strokeRect(rx, ry, rw, rh);
            this.shapeData = [
                { x: rx, y: ry, isVertex: true },
                { x: rx + rw, y: ry, isVertex: true },
                { x: rx + rw, y: ry + rh, isVertex: true },
                { x: rx, y: ry + rh, isVertex: true }
            ];
        } else if (shapeType === 1) { // Triangle
            const x1 = Phaser.Math.Between(50, gameWidth - 50);
            const y1 = Phaser.Math.Between(buttonAndMarginHeight, gameHeight - 150);
            const x2 = Phaser.Math.Between(x1 - 70, x1 + 70);
            const y2 = Phaser.Math.Between(y1 + 30, y1 + 120);
            const x3 = Phaser.Math.Between(x1 - 70, x1 + 70);
            let y3 = Phaser.Math.Between(y1 + 30, y1 + 120);
            while (y3 === y2) { // Ensure not a flat line with y2
                 y3 = Phaser.Math.Between(y1 + 30, y1 + 120);
            }

            graphics.beginPath();
            graphics.moveTo(x1, y1);
            graphics.lineTo(x2, y2);
            graphics.lineTo(x3, y3);
            graphics.closePath();
            graphics.fillPath();
            graphics.strokePath();
            this.shapeData = [
                { x: x1, y: y1, isVertex: true },
                { x: x2, y: y2, isVertex: true },
                { x: x3, y: y3, isVertex: true }
            ];
        } else { // Circle
            const radius = Phaser.Math.Between(25, 75);
            const cx = Phaser.Math.Between(50 + radius, gameWidth - radius - 50);
            const cy = Phaser.Math.Between(buttonAndMarginHeight + radius, gameHeight - radius - 50);
            graphics.fillCircle(cx, cy, radius);
            graphics.strokeCircle(cx, cy, radius);
            // For circles, no specific vertices for point-and-click measurement for now.
            // Define some points if needed later, e.g. center and point on circumference.
            this.shapeData = []; // Mark as non-measurable by having no vertex data
        }
    }

    handlePointSelection(pointer) {
        if (!this.shapeData || this.shapeData.length === 0) {
            // If clicked on empty space or non-measurable shape, clear old selections
            if (this.selectedPoints.length > 0) { // Only clear if there was something selected
                this.clearMeasurements();
            }
            return;
        }

        let clickedOnVertex = false;
        let closestVertex = null;
        let minDistance = 15; // Click tolerance

        for (const vertex of this.shapeData) {
            if (!vertex.isVertex) continue; // Skip non-vertex points if any (e.g. circle center)

            const distance = Phaser.Math.Distance.Between(pointer.x, pointer.y, vertex.x, vertex.y);
            if (distance < minDistance) {
                minDistance = distance;
                closestVertex = vertex;
                clickedOnVertex = true;
            }
        }

        if (clickedOnVertex) {
            // Check if the point is already selected (simple check by coordinates)
            const isAlreadySelected = this.selectedPoints.some(p => p.x === closestVertex.x && p.y === closestVertex.y);

            if (!isAlreadySelected) {
                if (this.selectedPoints.length >= 3) {
                    this.selectedPoints.shift(); // Keep max 3 points, remove oldest
                }
                this.selectedPoints.push({ x: closestVertex.x, y: closestVertex.y });
            } else {
                // Optional: deselect if clicked again. For now, do nothing or remove it.
                // this.selectedPoints = this.selectedPoints.filter(p => p.x !== closestVertex.x || p.y !== closestVertex.y);
            }
            this.updateMeasurements();
        } else {
            // Click was not on a vertex of the current shape, clear existing selections.
            this.clearMeasurements();
        }
    }

    updateMeasurements() {
        // Clear previous markers (includes lines and points)
        this.selectionMarkers.forEach(marker => marker.destroy());
        this.selectionMarkers = [];

        // Clear previous text
        if (this.measurementText) {
            this.measurementText.destroy();
            this.measurementText = null;
        }

        if (this.selectedPoints.length === 0) return;

        // Add a new graphics object for new markers
        const markerGraphics = this.add.graphics();
        this.selectionMarkers.push(markerGraphics); // Store for clearing

        // Draw new markers for selected points
        markerGraphics.fillStyle(0xff0000, 1); // Red markers
        markerGraphics.lineStyle(1, 0x000000, 1); // Black outline for markers
        this.selectedPoints.forEach(p => {
            markerGraphics.fillCircle(p.x, p.y, 6); // Draw small circle at each selected point
            markerGraphics.strokeCircle(p.x, p.y, 6);
        });

        let textToShow = "";
        const textStyle = { font: '16px Arial', fill: '#000000', backgroundColor: 'rgba(255,255,255,0.8)', padding: { x: 8, y: 4 }, align: 'left' };
        const textX = 30; // Position text from left
        let textY = this.sys.game.config.height - 90; // Position text at the bottom

        if (this.selectedPoints.length === 2) {
            const p1 = this.selectedPoints[0];
            const p2 = this.selectedPoints[1];
            const length = Phaser.Math.Distance.Between(p1.x, p1.y, p2.x, p2.y);
            textToShow = `Length: ${length.toFixed(1)} units`;

            // Draw line between points
            markerGraphics.lineStyle(2, 0x00aa00, 0.8); // Green line for length
            markerGraphics.beginPath();
            markerGraphics.moveTo(p1.x, p1.y);
            markerGraphics.lineTo(p2.x, p2.y);
            markerGraphics.strokePath();

        } else if (this.selectedPoints.length === 3) {
            const p1 = this.selectedPoints[0];
            const p2 = this.selectedPoints[1]; // Angle vertex is P2 (middle point)
            const p3 = this.selectedPoints[2];

            const lengthP1P2 = Phaser.Math.Distance.Between(p1.x, p1.y, p2.x, p2.y);
            const lengthP2P3 = Phaser.Math.Distance.Between(p2.x, p2.y, p3.x, p3.y);
            
            textToShow = `P1-P2: ${lengthP1P2.toFixed(1)}\nP2-P3: ${lengthP2P3.toFixed(1)}\n`;

            // Angle calculation at P2
            const angleRadP2P1 = Phaser.Math.Angle.BetweenPoints(p2, p1);
            const angleRadP2P3 = Phaser.Math.Angle.BetweenPoints(p2, p3);
            
            let angleDeg = Phaser.Math.RadToDeg(angleRadP2P3 - angleRadP2P1);
            angleDeg = (angleDeg + 360) % 360; // Normalize to 0-360

            // Optionally, always show the smaller angle (e.g., interior angle of a triangle)
            if (angleDeg > 180) {
                angleDeg = 360 - angleDeg;
            }

            textToShow += `Angle at P2: ${angleDeg.toFixed(1)}Â°`;

            // Draw lines for angle representation
            markerGraphics.lineStyle(2, 0x00aa00, 0.8); 
            markerGraphics.beginPath();
            markerGraphics.moveTo(p1.x, p1.y);
            markerGraphics.lineTo(p2.x, p2.y);
            markerGraphics.lineTo(p3.x, p3.y);
            markerGraphics.strokePath();
        }

        if (textToShow) {
            this.measurementText = this.add.text(textX, textY, textToShow, textStyle);
        }
    }

    update() {
        // Game loop, will be called continuously
        // console.log('MainScene update');
    }
}

// Phaser Game Configuration
const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    parent: 'game-container',
    scene: [MainScene],
    backgroundColor: '#ffffff',
    physics: {
        default: 'arcade',
        arcade: {
            debug: false
        }
    }
};

// Initialize Phaser Game
const game = new Phaser.Game(config);
